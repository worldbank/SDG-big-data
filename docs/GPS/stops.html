<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 4 Finding Stops | GPS Analytics</title>
  <meta name="description" content="Guided step by step analysis of income based mobility patterns from GPS data." />
  <meta name="generator" content="bookdown 0.23 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 4 Finding Stops | GPS Analytics" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Guided step by step analysis of income based mobility patterns from GPS data." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 4 Finding Stops | GPS Analytics" />
  
  <meta name="twitter:description" content="Guided step by step analysis of income based mobility patterns from GPS data." />
  

<meta name="author" content="Chapter 4 Finding Stops | GPS Analytics Group" />


<meta name="date" content="2021-08-26" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="geocode.html"/>
<link rel="next" href="defining-home-and-work-locations.html"/>
<script src="libs/header-attrs-2.10/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">GPS Mobility Analysis</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="data.html"><a href="data.html"><i class="fa fa-check"></i><b>2</b> Data</a>
<ul>
<li class="chapter" data-level="2.1" data-path="data.html"><a href="data.html#gps-data"><i class="fa fa-check"></i><b>2.1</b> GPS Data</a></li>
<li class="chapter" data-level="2.2" data-path="data.html"><a href="data.html#wealth-index-data"><i class="fa fa-check"></i><b>2.2</b> Wealth Index Data</a></li>
<li class="chapter" data-level="2.3" data-path="data.html"><a href="data.html#administrative-boundaries-data"><i class="fa fa-check"></i><b>2.3</b> Administrative Boundaries Data</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geocode.html"><a href="geocode.html"><i class="fa fa-check"></i><b>3</b> Geocode</a>
<ul>
<li class="chapter" data-level="3.1" data-path="geocode.html"><a href="geocode.html#efficient-spatial-joining-and-geospatial-indexing"><i class="fa fa-check"></i><b>3.1</b> Efficient spatial joining and Geospatial Indexing</a></li>
<li class="chapter" data-level="3.2" data-path="geocode.html"><a href="geocode.html#code"><i class="fa fa-check"></i><b>3.2</b> Code</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="geocode.html"><a href="geocode.html#loading-administrative-units"><i class="fa fa-check"></i><b>3.2.1</b> Loading administrative units</a></li>
<li class="chapter" data-level="3.2.2" data-path="geocode.html"><a href="geocode.html#loading-ping-data-and-h3-indexing"><i class="fa fa-check"></i><b>3.2.2</b> Loading ping data and h3 indexing</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="geocode.html"><a href="geocode.html#initial-coarse-geo-spatial-join-with-shapefiles"><i class="fa fa-check"></i><b>3.3</b> Initial coarse geo-spatial join with shapefiles</a></li>
<li class="chapter" data-level="3.4" data-path="geocode.html"><a href="geocode.html#final-exact-join-with-a-subset-of-the-shapefiles"><i class="fa fa-check"></i><b>3.4</b> Final exact join with a subset of the shapefiles</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="stops.html"><a href="stops.html"><i class="fa fa-check"></i><b>4</b> Finding Stops</a>
<ul>
<li class="chapter" data-level="4.1" data-path="stops.html"><a href="stops.html#definition"><i class="fa fa-check"></i><b>4.1</b> Definition</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="stops.html"><a href="stops.html#get-stop-locations"><i class="fa fa-check"></i><b>4.1.1</b> Get stop locations</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="stops.html"><a href="stops.html#clustering-recurrent-stops"><i class="fa fa-check"></i><b>4.2</b> Clustering recurrent stops</a></li>
<li class="chapter" data-level="4.3" data-path="stops.html"><a href="stops.html#appending-pings-from-recent-dates"><i class="fa fa-check"></i><b>4.3</b> Appending pings from recent dates</a></li>
<li class="chapter" data-level="4.4" data-path="stops.html"><a href="stops.html#stops-geocoding"><i class="fa fa-check"></i><b>4.4</b> Stops geocoding</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="defining-home-and-work-locations.html"><a href="defining-home-and-work-locations.html"><i class="fa fa-check"></i><b>5</b> Defining Home and Work Locations</a>
<ul>
<li class="chapter" data-level="5.1" data-path="defining-home-and-work-locations.html"><a href="defining-home-and-work-locations.html#seasonal-patterns"><i class="fa fa-check"></i><b>5.1</b> Seasonal patterns</a></li>
<li class="chapter" data-level="5.2" data-path="defining-home-and-work-locations.html"><a href="defining-home-and-work-locations.html#code-1"><i class="fa fa-check"></i><b>5.2</b> Code</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="mobility.html"><a href="mobility.html"><i class="fa fa-check"></i><b>6</b> Mobility Patterns</a>
<ul>
<li class="chapter" data-level="6.1" data-path="mobility.html"><a href="mobility.html#individuals-selection"><i class="fa fa-check"></i><b>6.1</b> Individual’s selection</a></li>
<li class="chapter" data-level="6.2" data-path="mobility.html"><a href="mobility.html#measures"><i class="fa fa-check"></i><b>6.2</b> Measures</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="mobility.html"><a href="mobility.html#measuring-mobility"><i class="fa fa-check"></i><b>6.2.1</b> Measuring mobility</a></li>
<li class="chapter" data-level="6.2.2" data-path="mobility.html"><a href="mobility.html#measuring-change"><i class="fa fa-check"></i><b>6.2.2</b> Measuring change</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="migration.html"><a href="migration.html"><i class="fa fa-check"></i><b>7</b> Migration Patterns</a></li>
<li class="chapter" data-level="8" data-path="optimization.html"><a href="optimization.html"><i class="fa fa-check"></i><b>8</b> Parameter Optimization</a></li>
<li class="chapter" data-level="9" data-path="windex.html"><a href="windex.html"><i class="fa fa-check"></i><b>9</b> Wealth Index</a></li>
<li class="chapter" data-level="10" data-path="voronoi.html"><a href="voronoi.html"><i class="fa fa-check"></i><b>10</b> Voronoi</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">GPS Analytics</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="stops" class="section level1" number="4">
<h1><span class="header-section-number">Chapter 4</span> Finding Stops</h1>
<div id="definition" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Definition</h2>
<p>Pings recorded from the gps devices are often noisy: unless an user is perfectly still in a place, the mobile will record
slightly different positions. As an example, if an user is at home and he moves between the different rooms of the house, we want to
group all the pings under a single label, home, to analyze the time spent at each location.
This would not be possible by considering individual pings. A standard procedure to
reduce the noise is to compute stop locations, by spatially and temporally clustering the raw pings.
## Infostop</p>
<p>In order to do this we need both the spatial and the temporal data from each ping. This
is, how far are consecutive pings from each other in time and space. We rely on the first part of the
<a href="https://arxiv.org/pdf/2003.14370.pdf">infostop</a> algorithm to detect stop-locations
or <em>stays</em>.
Infostop is based in some heuristics:</p>
<ul>
<li><span class="math inline">\(r_1\)</span>: The maximum distance between any pair of points within the same stop.</li>
<li><span class="math inline">\(n_{min}\)</span>: The minimum number of points that make up a stop.</li>
<li><span class="math inline">\(t_{min}\)</span>: The minimum duration of a stop.</li>
<li><span class="math inline">\(t_{max}\)</span>: The maximum time difference between two consecutive pings.</li>
</ul>
<p>Then in order to have a <em>stop</em> we would need to satisfy that some consecutive pings are all less than <span class="math inline">\(r_1\)</span> meters apart,
the time span between the first and the last pings is more than <span class="math inline">\(t_{min}\)</span> seconds, there’s no more than <span class="math inline">\(t_{max}\)</span>
seconds between consecutive pairs and each stop cannot be composed of less than <span class="math inline">\(n_{min}\)</span> pings.</p>
<p>Particularly we use the Python function <code>get_stationary_events()</code> in the <a href="https://github.com/ulfaslak/infostop">Infostop package</a>,
that is a wrapper around an efficient c++ implementation for computing stationary events, i.e. points of a trace that are
close in time and space and that can be grouped together under a single label. Each time we find a stationary event, we
associate it to a stop location, with as coordinates the centroid of the points that form the event and as duration
the difference in time between the first point of the event and the last point of the event.</p>
<p>Differently from infostop, we choose to use DBSCAN instead of Infomap to cluster stop locations.
## Code
### Data preparation</p>
<p>Once we load the required data, we make sure that they meet the timezone metadata requirements and that their coordinates
are valid geographical points.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="stops.html#cb6-1" aria-hidden="true" tabindex="-1"></a>filter_string <span class="op">=</span> <span class="ss">f&quot;accuracy &gt;=0 AND accuracy &lt;= 200 AND lat &gt; -90 AND lat &lt; 90 AND lon &gt; -180 AND lon &lt; 180&quot;</span></span>
<span id="cb6-2"><a href="stops.html#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="stops.html#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> tz: <span class="co"># add a check on TZ_OFFSET</span></span>
<span id="cb6-4"><a href="stops.html#cb6-4" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> spark.sql(<span class="ss">f&quot;SELECT  device_id AS user_id, lat, lon, accuracy, timestamp, TZ_OFFSET_SEC FROM default.veraset_</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">_tz WHERE country = &#39;</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">&#39; AND </span><span class="sc">{</span>filter_string<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-5"><a href="stops.html#cb6-5" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> (pings</span>
<span id="cb6-6"><a href="stops.html#cb6-6" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;epoch_time&#39;</span>, col(<span class="st">&quot;timestamp&quot;</span>) <span class="op">+</span> col(<span class="st">&quot;TZ_OFFSET_SEC&quot;</span>).cast(<span class="st">&quot;long&quot;</span>))</span>
<span id="cb6-7"><a href="stops.html#cb6-7" aria-hidden="true" tabindex="-1"></a>           .drop(<span class="st">&quot;TZ_OFFSET_SEC&quot;</span>, <span class="st">&quot;timestamp&quot;</span>))</span>
<span id="cb6-8"><a href="stops.html#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> tz:</span>
<span id="cb6-9"><a href="stops.html#cb6-9" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> spark.sql(<span class="ss">f&quot;SELECT  device_id AS user_id, lat, lon, accuracy, timestamp FROM default.veraset_primary_1  WHERE country = &#39;</span><span class="sc">{c.</span>country<span class="sc">}</span><span class="ss">&#39; AND </span><span class="sc">{</span>filter_string<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-10"><a href="stops.html#cb6-10" aria-hidden="true" tabindex="-1"></a>  pings <span class="op">=</span> (pings</span>
<span id="cb6-11"><a href="stops.html#cb6-11" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;time&#39;</span>, F.to_timestamp(<span class="st">&#39;timestamp&#39;</span>))</span>
<span id="cb6-12"><a href="stops.html#cb6-12" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;new_time&#39;</span>, F.from_utc_timestamp(<span class="st">&#39;time&#39;</span>, tz))</span>
<span id="cb6-13"><a href="stops.html#cb6-13" aria-hidden="true" tabindex="-1"></a>           .withColumn(<span class="st">&#39;epoch_time&#39;</span>, F.unix_timestamp(<span class="st">&#39;new_time&#39;</span>))</span>
<span id="cb6-14"><a href="stops.html#cb6-14" aria-hidden="true" tabindex="-1"></a>           .drop(<span class="st">&#39;timestamp&#39;</span>, <span class="st">&#39;time&#39;</span>, <span class="st">&#39;new_time&#39;</span>))</span>
<span id="cb6-15"><a href="stops.html#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-16"><a href="stops.html#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">raise</span> <span class="pp">Exception</span> (<span class="st">&quot;Undefined time zone in config or tz_offset in input table&quot;</span>)</span></code></pre></div>
<div id="get-stop-locations" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> Get stop locations</h3>
<p>Now we have the data ready to identify stops, we only need to sort pings by their timestamp for each user.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="stops.html#cb7-1" aria-hidden="true" tabindex="-1"></a>sl <span class="op">=</span> (pings</span>
<span id="cb7-2"><a href="stops.html#cb7-2" aria-hidden="true" tabindex="-1"></a>      .orderBy(<span class="st">&quot;epoch_time&quot;</span>)</span>
<span id="cb7-3"><a href="stops.html#cb7-3" aria-hidden="true" tabindex="-1"></a>      .groupBy(<span class="st">&quot;user_id&quot;</span>)</span>
<span id="cb7-4"><a href="stops.html#cb7-4" aria-hidden="true" tabindex="-1"></a>      .<span class="bu">apply</span>(get_stop_location, args<span class="op">=</span>(radius, stay_time,</span>
<span id="cb7-5"><a href="stops.html#cb7-5" aria-hidden="true" tabindex="-1"></a>             min_pts_per_stop_location, max_time_stop_location,</span>
<span id="cb7-6"><a href="stops.html#cb7-6" aria-hidden="true" tabindex="-1"></a>             max_accuracy, db_scan_radius))</span>
<span id="cb7-7"><a href="stops.html#cb7-7" aria-hidden="true" tabindex="-1"></a>      .dropna())</span></code></pre></div>
<p>Where the user defined function <code>get_stop_location()</code> composed by other functions which at the end will yield
a data frame with user id, stop beginning timestamp, stop end timestamp, a centroid coordinate pair from the original pings,
a cluster label from a <a href="https://www.aaai.org/Papers/KDD/1996/KDD96-037.pdf">DBSCAN clustering algorithm</a>, the median accuracy of
the pings and the total number of pings that compose the given stop.</p>
<p>For DBSCAN we also use <span class="math inline">\(\epsilon=50m\)</span> and the minimum accuracy for us to keep a ping is <span class="math inline">\(100m\)</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="stops.html#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_intervals(centroids, labels, timestamps, accuracy, input_data):</span>
<span id="cb8-2"><a href="stops.html#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># if the label is -1 it means that the point doesn&#39;t belong to any cluster. Otherwise there should be at least 2 points for a stop locations</span></span>
<span id="cb8-3"><a href="stops.html#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and they should</span></span>
<span id="cb8-4"><a href="stops.html#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     assert (len(centroids) == len(community_labels))</span></span>
<span id="cb8-5"><a href="stops.html#cb8-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="stops.html#cb8-6" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-7"><a href="stops.html#cb8-7" aria-hidden="true" tabindex="-1"></a>    trajectory <span class="op">=</span> []</span>
<span id="cb8-8"><a href="stops.html#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(labels):</span>
<span id="cb8-9"><a href="stops.html#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> labels[i] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb8-10"><a href="stops.html#cb8-10" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-11"><a href="stops.html#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="stops.html#cb8-12" aria-hidden="true" tabindex="-1"></a>            start_index <span class="op">=</span> i</span>
<span id="cb8-13"><a href="stops.html#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(labels)) <span class="kw">and</span> (labels[i] <span class="op">==</span> labels[i <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb8-14"><a href="stops.html#cb8-14" aria-hidden="true" tabindex="-1"></a>                i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-15"><a href="stops.html#cb8-15" aria-hidden="true" tabindex="-1"></a>            trajectory.append((timestamps[start_index], timestamps[i], <span class="op">*</span>centroids[seen],</span>
<span id="cb8-16"><a href="stops.html#cb8-16" aria-hidden="true" tabindex="-1"></a>                               np.median(accuracy[start_index: i]), i <span class="op">-</span> start_index <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb8-17"><a href="stops.html#cb8-17" aria-hidden="true" tabindex="-1"></a>            seen <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-18"><a href="stops.html#cb8-18" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-19"><a href="stops.html#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="stops.html#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trajectory</span>
<span id="cb8-21"><a href="stops.html#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="stops.html#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_infostop(data, r1, min_staying_time, min_size, max_time_between, distance_metric):</span>
<span id="cb8-23"><a href="stops.html#cb8-23" aria-hidden="true" tabindex="-1"></a>    data_assertions(data)</span>
<span id="cb8-24"><a href="stops.html#cb8-24" aria-hidden="true" tabindex="-1"></a>    centroids, stat_labels <span class="op">=</span> get_stationary_events(</span>
<span id="cb8-25"><a href="stops.html#cb8-25" aria-hidden="true" tabindex="-1"></a>        data[:, :<span class="dv">3</span>], r1, min_size, min_staying_time, max_time_between, distance_metric)</span>
<span id="cb8-26"><a href="stops.html#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compute_intervals(centroids, stat_labels, data[:, <span class="dv">2</span>], data[:, <span class="dv">3</span>], data)</span>
<span id="cb8-27"><a href="stops.html#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="stops.html#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="stops.html#cb8-29" aria-hidden="true" tabindex="-1"></a>schema_df <span class="op">=</span> StructType([</span>
<span id="cb8-30"><a href="stops.html#cb8-30" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;user_id&#39;</span>, StringType(), <span class="va">False</span>),</span>
<span id="cb8-31"><a href="stops.html#cb8-31" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_start&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb8-32"><a href="stops.html#cb8-32" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;t_end&#39;</span>, LongType(), <span class="va">False</span>),</span>
<span id="cb8-33"><a href="stops.html#cb8-33" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lat&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb8-34"><a href="stops.html#cb8-34" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;lon&#39;</span>, DoubleType(), <span class="va">False</span>),</span>
<span id="cb8-35"><a href="stops.html#cb8-35" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;cluster_label&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb8-36"><a href="stops.html#cb8-36" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;median_accuracy&#39;</span>, DoubleType(), <span class="va">True</span>),</span>
<span id="cb8-37"><a href="stops.html#cb8-37" aria-hidden="true" tabindex="-1"></a>    StructField(<span class="st">&#39;total_pings_stop&#39;</span>, LongType(), <span class="va">True</span>),</span>
<span id="cb8-38"><a href="stops.html#cb8-38" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb8-39"><a href="stops.html#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="at">@pandas_udf</span>(schema_df, PandasUDFType.GROUPED_MAP)</span>
<span id="cb8-40"><a href="stops.html#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_stop_location(df, radius, stay_time, min_pts_per_stop_location, max_time_stop_location, max_accuracy, db_scan_radius):</span>
<span id="cb8-41"><a href="stops.html#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="stops.html#cb8-42" aria-hidden="true" tabindex="-1"></a>    identifier <span class="op">=</span> df[<span class="st">&#39;user_id&#39;</span>].values[<span class="dv">0</span>]</span>
<span id="cb8-43"><a href="stops.html#cb8-43" aria-hidden="true" tabindex="-1"></a>    df.sort_values(by<span class="op">=</span><span class="st">&#39;epoch_time&#39;</span>, inplace<span class="op">=</span><span class="va">True</span>)  <span class="co"># shouldnt be necessary</span></span>
<span id="cb8-44"><a href="stops.html#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="stops.html#cb8-45" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> df[[<span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>, <span class="st">&#39;epoch_time&#39;</span>, <span class="st">&quot;accuracy&quot;</span>]].values</span>
<span id="cb8-46"><a href="stops.html#cb8-46" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> run_infostop(data, r1<span class="op">=</span>radius, min_staying_time<span class="op">=</span>stay_time, min_size<span class="op">=</span>min_pts_per_stop_location,</span>
<span id="cb8-47"><a href="stops.html#cb8-47" aria-hidden="true" tabindex="-1"></a>                       max_time_between<span class="op">=</span>max_time_stop_location, distance_metric<span class="op">=</span><span class="st">&#39;haversine&#39;</span>)</span>
<span id="cb8-48"><a href="stops.html#cb8-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-49"><a href="stops.html#cb8-49" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(res, columns<span class="op">=</span>[</span>
<span id="cb8-50"><a href="stops.html#cb8-50" aria-hidden="true" tabindex="-1"></a>                      <span class="st">&quot;t_start&quot;</span>,  <span class="st">&quot;t_end&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>, <span class="st">&quot;median_accuracy&quot;</span>, <span class="st">&quot;total_pings_stop&quot;</span>])</span>
<span id="cb8-51"><a href="stops.html#cb8-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-52"><a href="stops.html#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># new filtering step based on median accuracy</span></span>
<span id="cb8-53"><a href="stops.html#cb8-53" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[df[<span class="st">&#39;median_accuracy&#39;</span>] <span class="op">&lt;</span> max_accuracy]</span>
<span id="cb8-54"><a href="stops.html#cb8-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-55"><a href="stops.html#cb8-55" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">&#39;user_id&#39;</span>] <span class="op">=</span> identifier</span>
<span id="cb8-56"><a href="stops.html#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> df.empty:</span>
<span id="cb8-57"><a href="stops.html#cb8-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">#       df[&#39;cluster_label&#39;] = get_labels(df[[&#39;lat&#39;, &#39;lon&#39;]])</span></span>
<span id="cb8-58"><a href="stops.html#cb8-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># notice that we don&#39;t have noise here, since any point that we consider is a stop location and hence has been already pre filtered by run_infostop (min_samples = 1 =&gt; no label =-1)</span></span>
<span id="cb8-59"><a href="stops.html#cb8-59" aria-hidden="true" tabindex="-1"></a>        db <span class="op">=</span> DBSCAN(eps<span class="op">=</span>db_scan_radius, min_samples<span class="op">=</span><span class="dv">1</span>, metric<span class="op">=</span><span class="st">&#39;haversine&#39;</span>,</span>
<span id="cb8-60"><a href="stops.html#cb8-60" aria-hidden="true" tabindex="-1"></a>                    algorithm<span class="op">=</span><span class="st">&#39;ball_tree&#39;</span>).fit(np.radians(df[[<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]].values))</span>
<span id="cb8-61"><a href="stops.html#cb8-61" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">&#39;cluster_label&#39;</span>] <span class="op">=</span> db.labels_</span>
<span id="cb8-62"><a href="stops.html#cb8-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-63"><a href="stops.html#cb8-63" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">&#39;cluster_label&#39;</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-64"><a href="stops.html#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code></pre></div>
</div>
</div>
<div id="clustering-recurrent-stops" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Clustering recurrent stops</h2>
<p>The clustering part is where our approach differs from the Infostop one, as the assign cluster labels by building a network of
stops if they’re located closer than a distance <span class="math inline">\(r_2\)</span> and then use the <a href="https://www.mapequation.org/assets/publications/RosvallBergstromPNAS2008Full.pdf">Infomap</a>
community detection algorithm while we proceed by clustering with DBSCAN as previously discussed. It is important to notice that
these clusters don’t depend on the time but only on the spatial distribution as we are interested in finding recurrent
visited locations.</p>
<p>Finally we split those stops that span multiple days into mutiple stops that are within a day: i.e. if we have a stop location
that spans from 22pm to 1am, we will split it into a stop location from 22pm to 23.59pm and another stop location from
00.00am to 1am.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="stops.html#cb9-1" aria-hidden="true" tabindex="-1"></a>sl <span class="op">=</span> (sl</span>
<span id="cb9-2"><a href="stops.html#cb9-2" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;total_duration_stop_location&quot;</span>, F.col(<span class="st">&quot;t_end&quot;</span>) <span class="op">-</span> F.col(<span class="st">&quot;t_start&quot;</span>))</span>
<span id="cb9-3"><a href="stops.html#cb9-3" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&#39;my_list&#39;</span>, make_list(F.to_timestamp(col(<span class="st">&#39;t_start&#39;</span>)), F.to_timestamp(col(<span class="st">&#39;t_end&#39;</span>))))</span>
<span id="cb9-4"><a href="stops.html#cb9-4" aria-hidden="true" tabindex="-1"></a>      .drop(<span class="st">&#39;t_start&#39;</span>, <span class="st">&#39;t_end&#39;</span>)</span>
<span id="cb9-5"><a href="stops.html#cb9-5" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;tmp&quot;</span>, F.explode(<span class="st">&quot;my_list&quot;</span>))</span>
<span id="cb9-6"><a href="stops.html#cb9-6" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;t_start&quot;</span>, F.col(<span class="st">&quot;tmp&quot;</span>).t_start)</span>
<span id="cb9-7"><a href="stops.html#cb9-7" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;t_end&quot;</span>, F.col(<span class="st">&quot;tmp&quot;</span>).t_end)</span>
<span id="cb9-8"><a href="stops.html#cb9-8" aria-hidden="true" tabindex="-1"></a>      .drop(<span class="st">&quot;tmp&quot;</span>, <span class="st">&quot;my_list&quot;</span>)</span>
<span id="cb9-9"><a href="stops.html#cb9-9" aria-hidden="true" tabindex="-1"></a>      .withColumn(<span class="st">&quot;duration&quot;</span>, F.col(<span class="st">&quot;t_end&quot;</span>) <span class="op">-</span> F.col(<span class="st">&quot;t_start&quot;</span>)))</span></code></pre></div>
</div>
<div id="appending-pings-from-recent-dates" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Appending pings from recent dates</h2>
<p>GPS data is passively gathered and as so it’s continiously growing, this translates in the need for contiously find stops and
assign cluster labels to them. This whole process is very computationally expensive and running it on the whole data would be
highly inefficient, this is why we keep old stops and only compute new ones, but there’s no way around the clustering part as
the labels can change every time. Fortunately the number of stops is several order magnitudes lower than the pings as the smallest
stop has at least two of them and we drop those that didn’t make up a stop.</p>
</div>
<div id="stops-geocoding" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> Stops geocoding</h2>
<p>Now that our data is composed by new aggregated points we replicate the indexing from <a href="geocode.html#geocode">3</a> but with the stops instead
of the pings.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="geocode.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="defining-home-and-work-locations.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/worldbank/SDG-big-data/tree/GPS-analytics/03-stops.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["gps-mobility.pdf", "gps-mobility.epub"],
"search": {
"engine": "lunr",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
